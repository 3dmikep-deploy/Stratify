# parser-core/python/gcode_analyzer.py
import re
import json
import numpy as np
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from pathlib import Path
import pandas as pd

@dataclass
class LayerAnalysis:
    """Detailed analysis of a single layer"""
    z_height: float
    thickness: float
    extrusion_moves: int
    travel_moves: int
    extrusion_distance: float
    travel_distance: float
    extrusion_volume: float
    print_time: float
    speed_profile: Dict[str, float]
    
@dataclass
class SlicerProfile:
    """Extracted or inferred slicer settings"""
    slicer_name: str
    version: Optional[str]
    layer_height: float
    first_layer_height: Optional[float]
    nozzle_diameter: float
    extrusion_width: float
    print_speed: float
    travel_speed: float
    retraction_distance: Optional[float]
    retraction_speed: Optional[float]
    temperature_nozzle: float
    temperature_bed: float
    infill_density: float
    infill_pattern: str
    support_enabled: bool
    wall_count: int
    top_layers: int
    bottom_layers: int

class GCodeAnalyzer:
    """Advanced G-code analysis and reverse engineering"""
    
    # Slicer signatures for detection
    SLICER_SIGNATURES = {
        'PrusaSlicer': [
            r'; generated by PrusaSlicer (\d+\.\d+\.\d+)',
            r'; filament_type = (.*)',
            r'; layer_height = ([\d.]+)',
        ],
        'Cura': [
            r';FLAVOR:.*',
            r';Generated with Cura_SteamEngine (.*)',
            r';LAYER_HEIGHT:([\d.]+)',
        ],
        'Simplify3D': [
            r'; Generated by Simplify3D\(R\) Version (.*)',
            r'; layerHeight,([\d.]+)',
        ],
        'Slic3r': [
            r'; generated by Slic3r (.*)',
            r'; layer_height = ([\d.]+)',
        ]
    }
    
    def __init__(self, filepath: Optional[str] = None):
        self.filepath = filepath
        self.raw_lines: List[str] = []
        self.commands: List[Dict] = []
        self.metadata: Dict = {}
        self.layers: List[LayerAnalysis] = []
        self.slicer_profile: Optional[SlicerProfile] = None
        self.state = {
            'x': 0, 'y': 0, 'z': 0, 'e': 0,
            'f': 0, 'absolute': True, 'absolute_e': True,
            'current_layer': 0, 'temperature': {'nozzle': 0, 'bed': 0}
        }
        
        if filepath:
            self.load_file(filepath)
    
    def load_file(self, filepath: str) -> None:
        """Load and preprocess G-code file"""
        self.filepath = filepath
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            self.raw_lines = f.readlines()
        
        print(f"Loaded {len(self.raw_lines)} lines from {Path(filepath).name}")
        self._parse_commands()
        self._detect_slicer()
        self._extract_metadata()
    
    def _parse_commands(self) -> None:
        """Parse G-code into structured commands"""
        for line_num, line in enumerate(self.raw_lines):
            line = line.strip()
            if not line or line.startswith(';'):
                # Store comments for metadata extraction
                if line.startswith(';'):
                    self._process_comment(line, line_num)
                continue
            
            # Remove inline comments
            if ';' in line:
                command_part, comment = line.split(';', 1)
                self._process_comment(';' + comment, line_num)
            else:
                command_part = line
            
            # Parse command
            cmd = self._parse_single_command(command_part.strip(), line_num)
            if cmd:
                self.commands.append(cmd)
                self._update_state(cmd)
    
    def _parse_single_command(self, line: str, line_num: int) -> Optional[Dict]:
        """Parse a single G-code command"""
        match = re.match(r'([GMTF])(\d+(?:\.\d+)?)(.*)', line)
        if not match:
            return None
        
        cmd_type = match.group(1)
        cmd_code = float(match.group(2))
        params_str = match.group(3)
        
        # Parse parameters
        params = {}
        for param_match in re.finditer(r'([A-Z])([-\d.]+)', params_str):
            params[param_match.group(1)] = float(param_match.group(2))
        
        return {
            'type': cmd_type,
            'code': cmd_code,
            'params': params,
            'line': line_num,
            'raw': line
        }
    
    def _detect_slicer(self) -> str:
        """Detect which slicer generated the G-code"""
        for slicer, patterns in self.SLICER_SIGNATURES.items():
            for pattern in patterns:
                for line in self.raw_lines[:100]:  # Check first 100 lines
                    if re.search(pattern, line):
                        self.metadata['slicer'] = slicer
                        match = re.search(pattern, line)
                        if match and match.groups():
                            self.metadata['slicer_version'] = match.group(1)
                        return slicer
        return 'Unknown'
    
    def _extract_metadata(self) -> None:
        """Extract metadata from comments"""
        # PrusaSlicer specific extraction
        if self.metadata.get('slicer') == 'PrusaSlicer':
            self._extract_prusaslicer_metadata()
        elif self.metadata.get('slicer') == 'Cura':
            self._extract_cura_metadata()
        # Add more slicer-specific extractors
    
    def _extract_prusaslicer_metadata(self) -> None:
        """Extract PrusaSlicer specific metadata"""
        patterns = {
            'layer_height': r'; layer_height = ([\d.]+)',
            'first_layer_height': r'; first_layer_height = ([\d.]+)',
            'nozzle_diameter': r'; nozzle_diameter = ([\d.]+)',
            'filament_type': r'; filament_type = (.*)',
            'print_speed': r'; perimeter_speed = ([\d.]+)',
            'infill_density': r'; fill_density = ([\d.]+)%',
            'temperature_nozzle': r'; temperature = ([\d.]+)',
            'temperature_bed': r'; bed_temperature = ([\d.]+)',
        }
        
        for key, pattern in patterns.items():
            for line in self.raw_lines[:200]:
                match = re.search(pattern, line)
                if match:
                    self.metadata[key] = match.group(1)
                    break
    
    def analyze_geometry(self) -> Dict:
        """Perform comprehensive geometric analysis"""
        analysis = {
            'bounding_box': self._calculate_bounding_box(),
            'layer_analysis': self._analyze_layers(),
            'movement_stats': self._analyze_movements(),
            'extrusion_stats': self._analyze_extrusion(),
            'time_estimate': self._estimate_print_time(),
            'pattern_detection': self._detect_patterns()
        }
        return analysis
    
    def _analyze_layers(self) -> List[LayerAnalysis]:
        """Analyze each layer in detail"""
        layers = []
        current_z = 0
        layer_commands = []
        
        for cmd in self.commands:
            if cmd['type'] == 'G' and cmd['code'] in [0, 1]:
                if 'Z' in cmd['params'] and cmd['params']['Z'] != current_z:
                    # New layer detected
                    if layer_commands:
                        layer = self._analyze_single_layer(
                            layer_commands, current_z
                        )
                        layers.append(layer)
                    
                    current_z = cmd['params']['Z']
                    layer_commands = [cmd]
                else:
                    layer_commands.append(cmd)
        
        # Don't forget the last layer
        if layer_commands:
            layer = self._analyze_single_layer(layer_commands, current_z)
            layers.append(layer)
        
        self.layers = layers
        return layers
    
    def _analyze_single_layer(self, commands: List[Dict], z: float) -> LayerAnalysis:
        """Analyze a single layer"""
        extrusion_moves = 0
        travel_moves = 0
        extrusion_dist = 0
        travel_dist = 0
        extrusion_vol = 0
        speeds = []
        
        prev_pos = {'x': 0, 'y': 0, 'e': 0}
        
        for cmd in commands:
            if cmd['type'] == 'G' and cmd['code'] in [0, 1]:
                # Calculate distances
                dx = cmd['params'].get('X', prev_pos['x']) - prev_pos['x']
                dy = cmd['params'].get('Y', prev_pos['y']) - prev_pos['y']
                dist = np.sqrt(dx**2 + dy**2)
                
                if 'E' in cmd['params']:
                    # Extrusion move
                    extrusion_moves += 1
                    extrusion_dist += dist
                    de = cmd['params']['E'] - prev_pos['e']
                    extrusion_vol += self._calculate_volume(de)
                    prev_pos['e'] = cmd['params']['E']
                else:
                    # Travel move
                    travel_moves += 1
                    travel_dist += dist
                
                if 'F' in cmd['params']:
                    speeds.append(cmd['params']['F'])
                
                # Update position
                prev_pos['x'] = cmd['params'].get('X', prev_pos['x'])
                prev_pos['y'] = cmd['params'].get('Y', prev_pos['y'])
        
        # Calculate layer thickness (will be refined with multiple layers)
        thickness = 0.2  # Default, will be calculated from z-differences
        
        # Estimate time (simplified)
        avg_speed = np.mean(speeds) if speeds else 3000
        print_time = (extrusion_dist / (avg_speed / 60))  # Convert mm/min to mm/s
        
        return LayerAnalysis(
            z_height=z,
            thickness=thickness,
            extrusion_moves=extrusion_moves,
            travel_moves=travel_moves,
            extrusion_distance=extrusion_dist,
            travel_distance=travel_dist,
            extrusion_volume=extrusion_vol,
            print_time=print_time,
            speed_profile={'avg': avg_speed, 'min': min(speeds) if speeds else 0,
                         'max': max(speeds) if speeds else 0}
        )
    
    def _calculate_volume(self, extrusion_length: float, 
                         filament_diameter: float = 1.75) -> float:
        """Calculate extruded volume from filament length"""
        radius = filament_diameter / 2
        return np.pi * radius**2 * extrusion_length
    
    def _detect_patterns(self) -> Dict:
        """Detect infill and perimeter patterns"""
        patterns = {
            'infill_type': 'unknown',
            'perimeter_count': 0,
            'support_detected': False,
            'bridging_detected': False
        }
        
        # Analyze movement patterns for infill detection
        # This is simplified - real implementation would be more complex
        for layer in self.layers[5:15]:  # Sample middle layers
            # Pattern detection logic here
            pass
        
        return patterns
    
    def infer_parameters(self) -> SlicerProfile:
        """Infer slicing parameters from geometric analysis"""
        # Calculate layer heights from z-differences
        layer_heights = []
        for i in range(1, len(self.layers)):
            height_diff = self.layers[i].z_height - self.layers[i-1].z_height
            if height_diff > 0:
                layer_heights.append(height_diff)
        
        avg_layer_height = np.median(layer_heights) if layer_heights else 0.2
        
        # Infer nozzle diameter from extrusion widths
        # This requires more complex analysis of extrusion patterns
        nozzle_diameter = 0.4  # Default, needs calculation
        
        # Build profile
        profile = SlicerProfile(
            slicer_name=self.metadata.get('slicer', 'Unknown'),
            version=self.metadata.get('slicer_version'),
            layer_height=avg_layer_height,
            first_layer_height=self.layers[0].thickness if self.layers else None,
            nozzle_diameter=nozzle_diameter,
            extrusion_width=nozzle_diameter * 1.2,  # Common ratio
            print_speed=self._calculate_avg_print_speed(),
            travel_speed=self._calculate_avg_travel_speed(),
            retraction_distance=self._detect_retraction_distance(),
            retraction_speed=None,
            temperature_nozzle=float(self.metadata.get('temperature_nozzle', 200)),
            temperature_bed=float(self.metadata.get('temperature_bed', 60)),
            infill_density=float(self.metadata.get('infill_density', '20').replace('%', '')),
            infill_pattern=self._detect_infill_pattern(),
            support_enabled=self._detect_supports(),
            wall_count=self._count_walls(),
            top_layers=self._count_top_layers(),
            bottom_layers=self._count_bottom_layers()
        )
        
        self.slicer_profile = profile
        return profile
    
    def _calculate_bounding_box(self) -> Dict:
        """Calculate the bounding box of the print"""
        x_vals = []
        y_vals = []
        z_vals = []
        
        for cmd in self.commands:
            if cmd['type'] == 'G' and cmd['code'] in [0, 1]:
                if 'X' in cmd['params']:
                    x_vals.append(cmd['params']['X'])
                if 'Y' in cmd['params']:
                    y_vals.append(cmd['params']['Y'])
                if 'Z' in cmd['params']:
                    z_vals.append(cmd['params']['Z'])
        
        return {
            'min': {'x': min(x_vals), 'y': min(y_vals), 'z': min(z_vals)},
            'max': {'x': max(x_vals), 'y': max(y_vals), 'z': max(z_vals)},
            'dimensions': {
                'x': max(x_vals) - min(x_vals),
                'y': max(y_vals) - min(y_vals),
                'z': max(z_vals) - min(z_vals)
            }
        }
    
    def export_analysis(self, output_path: str) -> None:
        """Export analysis results to JSON"""
        analysis = {
            'file': self.filepath,
            'metadata': self.metadata,
            'profile': asdict(self.slicer_profile) if self.slicer_profile else None,
            'geometry': self.analyze_geometry(),
            'layers': [asdict(layer) for layer in self.layers],
            'optimization_suggestions': self.generate_optimization_suggestions()
        }
        
        with open(output_path, 'w') as f:
            json.dump(analysis, f, indent=2)
    
    def generate_optimization_suggestions(self) -> List[Dict]:
        """Generate optimization suggestions based on analysis"""
        suggestions = []
        
        # Check layer height optimization
        if self.slicer_profile and self.slicer_profile.layer_height < 0.15:
            suggestions.append({
                'category': 'Speed',
                'title': 'Increase layer height',
                'description': f'Current layer height is {self.slicer_profile.layer_height}mm. '
                              f'Consider 0.2mm for faster prints.',
                'impact': 'High',
                'time_saving': '~30%'
            })
        
        # Check infill optimization
        if self.slicer_profile and self.slicer_profile.infill_density > 30:
            suggestions.append({
                'category': 'Material',
                'title': 'Reduce infill density',
                'description': f'Current infill is {self.slicer_profile.infill_density}%. '
                              f'20% is often sufficient for most prints.',
                'impact': 'Medium',
                'material_saving': '~15%'
            })
        
        return suggestions
    
    # Helper methods for parameter inference
    def _calculate_avg_print_speed(self) -> float:
        speeds = []
        for cmd in self.commands:
            if cmd['type'] == 'G' and cmd['code'] == 1 and 'F' in cmd['params']:
                if 'E' in cmd['params']:  # Only extrusion moves
                    speeds.append(cmd['params']['F'])
        return np.mean(speeds) if speeds else 3000
    
    def _calculate_avg_travel_speed(self) -> float:
        speeds = []
        for cmd in self.commands:
            if cmd['type'] == 'G' and cmd['code'] == 0 and 'F' in cmd['params']:
                speeds.append(cmd['params']['F'])
        return np.mean(speeds) if speeds else 6000
    
    def _detect_retraction_distance(self) -> Optional[float]:
        retractions = []
        for i in range(1, len(self.commands)):
            cmd = self.commands[i]
            if cmd['type'] == 'G' and cmd['code'] == 1:
                if 'E' in cmd['params']:
                    prev_e = self.commands[i-1]['params'].get('E', 0)
                    if cmd['params']['E'] < prev_e:
                        retractions.append(prev_e - cmd['params']['E'])
        return np.median(retractions) if retractions else None
    
    def _detect_infill_pattern(self) -> str:
        # Simplified pattern detection
        return self.metadata.get('infill_pattern', 'rectilinear')
    
    def _detect_supports(self) -> bool:
        # Check for support-related comments or patterns
        for line in self.raw_lines[:500]:
            if 'support' in line.lower():
                return True
        return False
    
    def _count_walls(self) -> int:
        # This would require analyzing perimeter patterns
        return 2  # Default
    
    def _count_top_layers(self) -> int:
        # Analyze solid infill at top
        return 3  # Default
    
    def _count_bottom_layers(self) -> int:
        # Analyze solid infill at bottom
        return 3  # Default
    
    def _process_comment(self, comment: str, line_num: int) -> None:
        """Process comment lines for metadata"""
        # Store for later processing
        pass
    
    def _update_state(self, cmd: Dict) -> None:
        """Update parser state based on command"""
        if cmd['type'] == 'G':
            if cmd['code'] == 90:
                self.state['absolute'] = True
            elif cmd['code'] == 91:
                self.state['absolute'] = False
            elif cmd['code'] in [0, 1]:
                for axis in ['X', 'Y', 'Z']:
                    if axis in cmd['params']:
                        if self.state['absolute']:
                            self.state[axis.lower()] = cmd['params'][axis]
                        else:
                            self.state[axis.lower()] += cmd['params'][axis]
    
    def _analyze_movements(self) -> Dict:
        """Analyze movement statistics"""
        return {
            'total_commands': len(self.commands),
            'movement_commands': sum(1 for c in self.commands 
                                   if c['type'] == 'G' and c['code'] in [0, 1]),
            'extrusion_commands': sum(1 for c in self.commands 
                                    if c['type'] == 'G' and 'E' in c.get('params', {}))
        }
    
    def _analyze_extrusion(self) -> Dict:
        """Analyze extrusion statistics"""
        total_extrusion = 0
        for cmd in self.commands:
            if cmd['type'] == 'G' and 'E' in cmd.get('params', {}):
                total_extrusion = max(total_extrusion, cmd['params']['E'])
        
        return {
            'total_filament': total_extrusion,
            'estimated_weight': total_extrusion * 0.00125 * 1.24  # PLA density
        }
    
    def _estimate_print_time(self) -> float:
        """Estimate total print time"""
        return sum(layer.print_time for layer in self.layers)